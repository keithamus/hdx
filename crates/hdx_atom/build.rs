use std::{env, path::Path};

use glob::glob;
use grep_matcher::{Captures, Matcher};
use grep_regex::RegexMatcher;
use grep_searcher::{sinks::UTF8, Searcher};

fn main() {
	let matcher =
		RegexMatcher::new_line_matcher("(?:atom!\\(\"|atomizable\\(\"|atom = \"|suffix = \"|prefix = \"|rename = \")([^\"]+)")
			.unwrap();
	let mut matches = vec![];
	for entry in glob("../**/*.rs").unwrap() {
		let mut searcher = Searcher::new();
		searcher
			.search_path(
				&matcher,
				entry.unwrap(),
				UTF8(|_lnum, line| {
					let mut captures = matcher.new_captures()?;
					matcher.captures_iter(line.as_bytes(), &mut captures, |captures| -> bool {
						matches.push(line[captures.get(1).unwrap()].to_owned());
                        true
					})?;
					Ok(true)
				}),
			)
			.unwrap();
	}

	matches.append(
		&mut vec![
			// hdx_lexer::Token::Kind names
			"unknown",
			"EOF",
			"Comment",
			"Ident",
			"Function",
			"AtKeyword",
			"Hash",
			"String",
			"BadString",
			"Url",
			"BadUrl",
			"Delim",
			"Number",
			"Percentage",
			"Dimension",
			"Whitespace",
			"Cdo",
			"Cdc",
			"Colon",
			"Semicolon",
			"Comma",
			"LeftSquare",
			"RightSquare",
			"LeftParen",
			"RightParen",
			"LeftCurly",
			"RightCurly",
			"",
			// HTML Tag Names
			"html",
			"base",
			"head",
			"link",
			"meta",
			"base",
			"link",
			"script",
			"style",
			"title",
			"style",
			"title",
			"body",
			"address",
			"article",
			"aside",
			"footer",
			"header",
			"h1",
			"h2",
			"h3",
			"h4",
			"h5",
			"h6",
			"hgroup",
			"main",
			"nav",
			"section",
			"search",
			"blockquote",
			"cite",
			"dd",
			"dt",
			"dl",
			"div",
			"dl",
			"dt",
			"dd",
			"dt",
			"dl",
			"dd",
			"dd",
			"figcaption",
			"figure",
			"figure",
			"figcaption",
			"hr",
			"li",
			"ol",
			"ul",
			"menu",
			"menu",
			"ul",
			"ul",
			"li",
			"ol",
			"p",
			"pre",
			"ul",
			"a",
			"abbr",
			"b",
			"ont-weigh",
			"bdi",
			"bdo",
			"br",
			"cite",
			"code",
			"data",
			"dfn",
			"p",
			"dt",
			"dd",
			"em",
			"i",
			"kbd",
			"mark",
			"q",
			"blockquote",
			"rp",
			"ruby",
			"rt",
			"rt",
			"ruby",
			"ruby",
			"s",
			"samp",
			"small",
			"span",
			"strong",
			"sub",
			"sup",
			"time",
			"u",
			"var",
			"wbr",
			"area",
			"audio",
			"ediaStrea",
			"img",
			"map",
			"area",
			"track",
			"video",
			"embed",
			"iframe",
			"object",
			"picture",
			"source",
			"img",
			"portal",
			"source",
			"svg",
			"canvas",
			"noscript",
			"script",
			"del",
			"ins",
			"caption",
			"col",
			"colgroup",
			"colgroup",
			"table",
			"tbody",
			"tr",
			"table",
			"td",
			"tfoot",
			"th",
			"thead",
			"tr",
			"td",
			"th",
			"button",
			"datalist",
			"option",
			"fieldset",
			"label",
			"form",
			"input",
			"label",
			"legend",
			"fieldset",
			"meter",
			"optgroup",
			"select",
			"option",
			"optgroup",
			"datalist",
			"output",
			"progress",
			"select",
			"textarea",
			"details",
			"summary",
			"dialog",
			"summary",
			"details",
			"slot",
			"template",
			"acronym",
			"big",
			"center",
			"slot",
			"slot",
			"dir",
			"ul",
			"font",
			"frame",
			"frameset",
			"frameset",
			"frame",
			"image",
			"img",
			"marquee",
			"menuitem",
			"nobr",
			"noembed",
			"object",
			"noframes",
			"frame",
			"param",
			"object",
			"plaintext",
			"rb",
			"rtc",
			"rb",
			"ruby",
			"rb",
			"rt",
			"rtc",
			"slot",
			"strike",
			"tt",
			"xmp",
		]
		.iter()
		.map(|&s| s.into())
		.collect(),
	);

	string_cache_codegen::AtomType::new("Atom", "atom!")
		.atoms(matches)
		.write_to_file(&Path::new(&env::var("OUT_DIR").unwrap()).join("hdx_atom.rs"))
		.unwrap()
}
